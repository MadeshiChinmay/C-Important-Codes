#include<bits/stdc++.h>
using namespace std;

//SEGMENT TREE  
// Range Minimum Query

int lazy[1000] = {0};
void updateRangeLazy(int* tree,int ss ,int se ,int l ,int r,int inc , int index)
{
    //First step if You have a lazy value at the current node
    // then you need to resolve it first
    if(lazy[index]!=0)
    {
        tree[index]+= lazy[index];

        //if not a leaf node
        if(ss!=se)
        {
            lazy[2*index] += lazy[index];
            lazy[2*index+1] += lazy[index];
        }
        lazy[index] = 0;
    }
    /*HERE NOW WE HAVE RESOLVED THE LAZY VALUE*/
    // Out of Bounds
    if(r<ss || l>se) return; 

    //Complete Overlap
    if(ss>=l && r>=se)
    {
        tree[index] += inc;

        if(ss!=se){
            lazy[2*index] += inc;
            lazy[2*index+1] += inc; 
        }
        return;
    }
    //Call on left and right
    int mid=(ss+se)/2;
    updateRangeLazy(tree,ss,mid,l,r,inc,2*index);
    updateRangeLazy(tree,mid+1,se,l,r,inc,2*index+1);
    tree[index] = min(tree[2*index],tree[2*index+1]);
    return;
    //Now we have to modify the Querying Logic also
}

int queryLazy(int *tree,int ss,int se,int qs,int qe,int index)
{
    //Resolve the lazy value
    if(lazy[index]!=0)
    {
        tree[index] += lazy[index];
        if(ss!=se)
        {
            lazy[2*index] += lazy[index];
            lazy[2*index+1] += lazy[index];
        }
        lazy[index] = 0;
    }

    //No overlap
    if(ss>qe || se<qs)return INT_MAX;

    //Complete Overlap
    if(ss>=qs && se<=qe)
        return tree[index];

    //Partial 
    int mid = (ss+se)/2;
    int left = queryLazy(tree,ss,mid,qs,qe,2*index);
    int right = queryLazy(tree,mid+1,se,qs,qe,2*index+1);
    return min(left,right);
}


int query(int *tree,int ss,int se,int qs,int qe,int index)
{
    //qe and qs are query range

    //Complete Overlap
    if(ss>=qs && se<=qe)
    {
        return tree[index];
    }

    //No Overlap
    if(qe<ss || qs>se) return INT_MAX;

    //Partial Overalp -> Call both Sides and update the answer
    int mid = (ss+se)/2;
    int leftAns = query(tree,ss,mid,qs,qe,2*index);
    int rightAns = query(tree,mid+1,se,qs,qe,2*index+1);

    return min(leftAns,rightAns);
}


void buildTree(int *a,int s,int e,int *tree,int index)
{
    //cout<<"index "<<index<<endl;
    if(s==e)
    {
        tree[index]=a[s];
        return ;
    }
     //Rec Case
    int mid = (s+e)/2;
    //LEFT CHILD
    buildTree(a,s,mid,tree,2*index);
    //RIGHT CHILD
    buildTree(a,mid+1,e,tree,2*index+1);

    tree[index] = min(tree[2*index+1] , tree[2*index]);

}


void updateNode(int * tree,int ss,int se,int i,int increment,int index)
{
    //No overlap
    if(i<ss || i>se)return ;

    // Reached Leaf Node
    if(ss==se)
    {
        tree[index]+=increment;
        return;
    }
    //Partial Overlap
    int mid = (ss+se)/2;
    updateNode(tree,ss,mid,i,increment,2*index);
    updateNode(tree,mid+1,se,i,increment,2*index+1);

    //Update the parents as well while going back
    tree[index]=min(tree[2*index],tree[2*index+1]);
}

void updateRange(int* tree,int ss,int se,int l,int r,int increment,int index)
{   
    //No overlap
    if(r<ss || l>se)return ;

    // Reached Leaf Node
    if(ss==se)
    {
        tree[index]+=increment;
        return;
    }

    //Partial Overlap or Complete Overlap
    int mid = (ss+se)/2;
    updateRange(tree,ss,mid,l,r,increment,2*index);
    updateRange(tree,mid+1,se,l,r,increment,2*index+1);

    //Update the parents as well while going back
    tree[index]=min(tree[2*index],tree[2*index+1]);
}

int32_t main()
{
    int a[]={1,3,2,-5,6,4};
    int n = sizeof(a)/sizeof(int);

    int* tree = new int[4*n+1];
    //cout<<"Calling Build Tree"<<endl;
    buildTree(a,0,n-1,tree,1);
    //cout<<"Printing "<<endl;
    {
        // for(int i=1;i<=4*n+1;i++)
        //     cout<<tree[i]<<" ";
        // cout<<endl;
    }

    

    //UPDATE

    // int i,increment;
    // cin>>i>>increment;
    {
        // updateNode(tree,0,n-1,2,10,1);
        // updateNode(tree,0,n-1,3,15,1);
    }

    //UPDATE Range

    //updateRange(tree,0,n-1,2,3,10,1);
    updateRangeLazy(tree,0,n-1,2,3,10,1);



    //QUERYING
    int l,r;
    cin>>l>>r;
    cout<<queryLazy(tree,0,n-1,l,r,1);




}
